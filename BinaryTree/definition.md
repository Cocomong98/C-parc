# Binary Tree

바이너리 트리의 풀 노드 = 밑의 노드가 2개일 때

리프 노드 = 스스로가 마지막일 때 

level (root가 1부터 시작) = n이라 했을 때,

 각 단계에 있는 노드의 수(최대) = 2^(k-1)
 해당 단계까지 있는 모든 노드의 수 = 

완전히 꽉 찬 이진 트리 = full binary tree

그렇지 않은 것 = complete binary tree

컴플리트의 기준 : 왼->오로 채우는 순서. 끝까지 차있지는 않아도 이전 단계는 다 차있어야 함

생성할때도, 지울때도 이와 같음


# complete binay tree (CBT) 

CBT에 있는 노드들을 array에 나열할 수 있음 (순차적으로 꽉 차있으니까 가능)

여기서 index가 4인 값에 대해서 다룬다고 가정

 - 부모 노드 구하기
   - index(4) / 2 = 2 (2번째 index가 parnet node)
   - 값이 1인 경우, 현재 노드가 root라는 의미이다
 - 자녀 노드 (왼쪽) 구하기
   - index(4) * 2 = 8 (8번째 index가 child node)
   - 결과가 전체 노드의 개수보다 크면 왼쪽 child는 없는 것임
 - 자녀 노드 (오른쪽) 구하기
   - index(4) * 2 + 1 = 9 (8번째 index가 child node)
   - 결과가 전체 노드의 개수보다 크면 오른쪽 child는 없는 것임

노드 저장을 위해서 필요한 element수 계산 = 2^(level)

CBT이거나 FBT인 경우에는 ARRAY에 넣는 것이 제일 효율적이겠지만, 그렇지 않으면 상당히 비효율적임

그럼 뭘 쓰나? 링크드 리스트 쓰면 된다


## 최종정리

    - Level이 k인 이진 트리의 최대 노드의 개수 (해당 레벨에 위치한 노드만 따짐)
        : 2^(k-1)
    - level이 k인 이진 트리의 최대 전체 노드의 개수 (트리 전체 노드를 따짐)
        : 2^k-1
    - n개의 노드를 가진 CBT의 최대 레벨
        : log2 (n+1)


원래 BT의 시간복잡도는 O(n)인 경우가 많은데, FBT이거나 CBT인 경우 O(logn)이 된다 
이건 최고 좋은 알고리즘이다 -> 그래서 Binary search가 중요하다